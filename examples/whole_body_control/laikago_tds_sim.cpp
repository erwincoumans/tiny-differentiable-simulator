// Example to control a laikago robot with hybrid actions generated by a
// pre-trained mpc stance leg controller and a swing leg controller.
// Example usage:
// examples/laikago_tds_sim examples/whole_body_control/mpc_ffn_model.json

#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
#include <nlohmann/json.hpp>

#include "math/neural_network.hpp"
#include "simple_robot.hpp"
#include "com_velocity_estimator.hpp"
#include "openloop_gait_generator.hpp"
#include "raibert_swing_leg_controller.hpp"

typedef double MyScalar;
typedef ::TINY::DoubleUtils MyTinyConstants;
typedef TinyAlgebra<double, MyTinyConstants> MyAlgebra;

using tds::NeuralNetwork;
using std::vector;

namespace {

// Set of {vx, vy, vz, v_angular} waypoints.
std::vector<std::vector<double>> desired_speeds{
    {0.6, 0., 0., 0.},
    {0.0, 0., 0., 0.8},
    {0.0, -0.2, 0., 0.},
    {0.0, 0., 0., -0.8},
    {0.0, 0.2, 0., 0.},
    {0.0, 0., 0., 0.}
};

int SECS_PER_PHASE = 5;
int TOTAL_SECS = SECS_PER_PHASE * desired_speeds.size();

vector<MyScalar> GetDesiredSpeed(int secs) {
  return desired_speeds[secs / SECS_PER_PHASE];
}

void ExtendVector(vector<MyScalar>& v1, const vector<MyScalar> v2) {
  v1.insert(v1.end(), v2.begin(), v2.end());
}

vector<MyScalar> GetMpcInput(const vector<MyScalar>& desired_speed,
                             double desired_twisting_speed,
                             tds::SimpleRobot& robot,
                             const tds::COMVelocityEstimator&
                             com_velocity_estimator,
                             tds::OpenloopGaitGenerator&
                             openloop_gait_generator
) {
  vector<MyScalar> friction_coeffs = {0.45, 0.45, 0.45, 0.45};
  vector<MyScalar> desired_com_position = {0.0, 0.0, 0.42};
  vector<MyScalar> desired_com_velocity = {desired_speed[0],
                                           desired_speed[1], 0.0};
  vector<MyScalar> desired_com_roll_pitch_yaw = {0.0, 0.0, 0.0};
  vector<MyScalar>
      desired_com_angular_velocity = {0.0, 0.0, desired_twisting_speed};
  vector<MyScalar> foot_contact_state;
  for (tds::LegState state: openloop_gait_generator.GetDesiredLegState()) {
    foot_contact_state.push_back(
        double(state == tds::STANCE || state == tds::EARLY_CONTACT));
  }

  vector<MyScalar> mpc_input;
  vector<MyScalar> com_vel = com_velocity_estimator.com_velocity_body_frame;
  vector<MyScalar> com_roll_pitch_yaw = robot.GetBaseRollPitchYaw();
  com_roll_pitch_yaw[2] = 0.0;
  vector<MyScalar> com_angular_velocity = robot.GetBaseRollPitchYawRate();
  vector<MyScalar> foot_positions_base_frame = robot
      .GetFootPositionsInBaseFrame();

  ExtendVector(mpc_input, com_vel);
  ExtendVector(mpc_input, com_roll_pitch_yaw);
  ExtendVector(mpc_input, com_angular_velocity);
  ExtendVector(mpc_input, foot_contact_state);
  ExtendVector(mpc_input, foot_positions_base_frame);
  ExtendVector(mpc_input, friction_coeffs);
  ExtendVector(mpc_input, desired_com_position);
  ExtendVector(mpc_input, desired_com_velocity);
  ExtendVector(mpc_input, desired_com_roll_pitch_yaw);
  ExtendVector(mpc_input, desired_com_angular_velocity);

  return mpc_input;
}

}

int main(int argc, char* argv[]) {
  if (argc != 2) {
    std::cerr
        << "usage: load_pytorch_network <path-to-exported-script-module>\n";
    return -1;
  }
  std::string nn_json_filename;
  tds::FileUtils::find_file(argv[1],
                            nn_json_filename);
  std::ifstream weights_json_file(nn_json_filename);
  nlohmann::json data;
  weights_json_file >> data;
  std::cout << "Json model loaded\n";

  NeuralNetwork<TinyAlgebra<double, TINY::DoubleUtils>> net(data);

  MeshcatUrdfVisualizer<MyAlgebra> meshcat_viz;
  std::cout << "Waiting for meshcat server" << std::endl;
  meshcat_viz.delete_all();

  double time_step = 0.001;
  tds::SimpleRobot robot(time_step, meshcat_viz);
  tds::COMVelocityEstimator com_velocity_estimator(&robot);
  tds::OpenloopGaitGenerator openloop_gait_generator(&robot);
  tds::RaibertSwingLegController
      raibert_swing_leg_controller(&robot, &openloop_gait_generator,
                                   &com_velocity_estimator);

  robot.Reset();
  openloop_gait_generator.Reset();
  com_velocity_estimator.Reset();
  raibert_swing_leg_controller.Reset();

  auto start_time = std::chrono::high_resolution_clock::now();
  int secs_since_start;
  while (secs_since_start < TOTAL_SECS) {
    std::this_thread::sleep_for(std::chrono::duration<double>(0.003));
    auto current_time = std::chrono::high_resolution_clock::now();
    secs_since_start = std::chrono::duration_cast<std::chrono::seconds>(
        current_time - start_time).count();

    auto speed_tuple = GetDesiredSpeed(secs_since_start);
    vector<MyScalar>
        desired_speed = {speed_tuple[0], speed_tuple[1], speed_tuple[2]};
    double desired_twisting_speed = speed_tuple[3];

    raibert_swing_leg_controller.SetDesiredSpeed(desired_speed);
    raibert_swing_leg_controller.SetDesiredTwistingSpeed
        (desired_twisting_speed);
    openloop_gait_generator.Update(robot.GetTimeSinceReset());
    com_velocity_estimator.Update();
    raibert_swing_leg_controller.Update();

    vector<MyScalar> mpc_input = GetMpcInput(desired_speed,
                                             desired_twisting_speed,
                                             robot,
                                             com_velocity_estimator,
                                             openloop_gait_generator);
    vector<MyScalar> mpc_stance_torque_output;
    net.compute(mpc_input, mpc_stance_torque_output);
    auto swing_action = raibert_swing_leg_controller.GetAction();

    std::vector<double> hybrid_action;
    for (size_t joint_id = 0; joint_id < robot.GetNumMotors(); joint_id++) {
      if (swing_action.find(joint_id) != swing_action.end()) {
        std::vector<double> command = swing_action[joint_id];
        for (double item: command) {
          hybrid_action.push_back(item);
        }
      } else {
        for (size_t i = 0; i < 4; i++) {
          hybrid_action.push_back(0.0);
        }
        hybrid_action.push_back(mpc_stance_torque_output[joint_id]);
      }
    }

    robot.Step(hybrid_action, tds::MOTOR_CONTROL_HYBRID, meshcat_viz);
  }
}